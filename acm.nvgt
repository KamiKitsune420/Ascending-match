#include"includes/*.nvgt"
bool marked;
bool []marknums;
int gameround;
int amount;
int numker;
timer hint_timer;
const int HINT_COOLDOWN = 10000; 
int[] nums;
sound gamemus;
menu m;
sound_pool p;
void main()
{
show_window("Asending Match!");
gameround=1;
wait(500);
speak("Press enter to start.");
dlgplay("sounds/TITLEBIT.wav");
mainmenu();
}
void gamesetup()
{
nums.resize(0);
marknums.resize(0);
if (gameround >= 1 && gameround < 5) {
amount = random(5, 10);        // Easy
}
else if (gameround >= 5 && gameround <= 10) {
amount = random(10, 15);       // Medium
}
else if (gameround > 10 && gameround < 20) {
amount = random(15, 25);       // Harder
}
else {
amount = random(30, 50);       // Very hard
}
for (int i = 0; i < amount; i++) {
nums.insert_last(random(1, 99));
}
numker = 0;
for (uint i = 0; i < amount; i++) {
marknums.insert_last(false); // all unmarked
}
speak("Round " + gameround + ". Numbers to arrange: " + amount + ".");
hint_timer.restart(); // reset hint cooldown every round
}
void game()
{
while (true)
{
wait(5);
if(key_down(KEY_PAGEUP))
{
gamemus.volume+=0.5;
}
else if(key_down(KEY_PAGEDOWN))
{
gamemus.volume-=0.5;
}
if (key_repeating(KEY_RIGHT)) {
if (numker < int(nums.length()) - 1) {
numker++;
p.play_stationary("sounds/curmove.wav", false);
if (marknums[numker]) {
    speak(nums[numker] + " (Marked)");
} else {
    speak(nums[numker]);
}
} else {
p.play_stationary("sounds/edge.wav", false);
}
}
if (key_repeating(KEY_LEFT)) {
if (numker > 0) {
numker--;
p.play_stationary("sounds/curmove.wav", false);
if (marknums[numker]) {
    speak(nums[numker] + " (Marked)");
} else {
    speak(nums[numker]);
}
} else {
p.play_stationary("sounds/edge.wav", false);
}
}
if (key_repeating(KEY_SPACE)) {
marknums[numker] = !marknums[numker];
int count = 0;
int first = -1, second = -1;
for (int i = 0; i < int(marknums.length()); i++) {
    if (marknums[i]) {
        count++;
        if (first == -1)
            first = i;
        else
            second = i;
    }
}
// Swap if 2 are marked
if (count == 2) {
    int temp = nums[first];
    nums[first] = nums[second];
    nums[second] = temp;
    p.play_stationary("sounds/swap.wav", false);
speak("Swapped");
// Clear all marks
for (int i = 0; i < int(marknums.length()); i++)
    marknums[i] = false;
// Check if sorted
bool sorted = true;
for (int i = 0; i < int(nums.length()) - 1; i++) {
    if (nums[i] > nums[i + 1]) {
        sorted = false;
        break;
    }
}
if (sorted) {
    p.play_stationary("sounds/NEXTROUND.wav", false); // optional
    speak("Round complete!");
    wait(1000);
    gameround++;
gamemus.pitch+=1;
    gamesetup(); // repopulates everything
game();
    return; // restart game loop from new round
}
} else {
    if (marknums[numker]) {
        p.play_stationary("sounds/marked.wav", false);
        speak("Marked");
    } else {
        p.play_stationary("sounds/unmarked.wav", false);
        speak("Unmarked");
    }
}
wait(150); // prevent accidental double presses
}
if (key_pressed(KEY_H)) {
    if (hint_timer.elapsed < HINT_COOLDOWN) {
        int secondsLeft = (HINT_COOLDOWN - hint_timer.elapsed) / 1000;
        speak("You can't use a hint yet. Please wait " + secondsLeft + " more second" + (secondsLeft == 1 ? "" : "s") + ".");
        p.play_stationary("sounds/hinterror.wav", false);
    } else {
        int correct = 0;
        int wrong = 0;
        int[] sorted_nums;
        for (uint i = 0; i < nums.length(); i++) {
            sorted_nums.insert_last(nums[i]);
        }
        sorted_nums.sort_ascending();

        for (uint i = 0; i < nums.length(); i++) {
            if (nums[i] == sorted_nums[i]) {
                correct++;
            } else {
                wrong++;
            }
        }

        speak(correct + " number" + (correct == 1 ? " is" : "s are") + " in the correct spot. " + wrong + " " + (wrong == 1 ? "is" : " are") + " out of place.");
        p.play_stationary("sounds/hint.wav", false);
        hint_timer.restart(); // restart cooldown
    }
}

if (key_pressed(KEY_ESCAPE)) {
fade(gamemus);
mainmenu();
}
}
}
